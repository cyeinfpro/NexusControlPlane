{% extends "base.html" %}

{% block content %}
<div class="page-head">
  <div class="page-title">
    <h1 class="h1">æ–‡ä»¶ç®¡ç† Â· {{ site.name }}</h1>
    <div class="meta" style="flex-wrap:wrap;">
      <span class="meta-item">æ ¹ç›®å½•ï¼š<span class="mono" style="word-break:break-all;">{{ root }}</span></span>
      {% if path %}
        <span class="meta-item">å½“å‰è·¯å¾„ï¼š<span class="mono" style="word-break:break-all;">{{ path }}</span></span>
      {% endif %}
    </div>
  </div>
  <div class="right">
    <a class="btn sm ghost" href="/websites/{{ site.id }}">è¿”å›ç«™ç‚¹</a>
  </div>
</div>

{% if error %}
  <div class="flash" style="background:rgba(239,68,68,0.15);border-color:rgba(239,68,68,0.4);">
    {{ error }}
  </div>
{% endif %}

<div class="card">
  <div class="row" style="justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;">
    <div class="col" style="min-width:240px;">
      <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
        {% for name, p in breadcrumbs %}
          <a href="/websites/{{ site.id }}/files?path={{ p }}" class="chip" style="text-decoration:none;">{{ name }}</a>
          {% if not loop.last %}<span class="muted">/</span>{% endif %}
        {% endfor %}
      </div>
      <div class="help compact" style="margin-top:6px;">æç¤ºï¼šå•æ–‡ä»¶ä¸Šä¼ ä¸Šé™ 200MBï¼ˆåˆ†ç‰‡ä¸Šä¼ ï¼‰ã€‚åˆ é™¤æ“ä½œä¸å¯æ¢å¤ã€‚</div>
    </div>

    <div class="col right" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
      <div class="dash-search" role="search" style="min-width:240px;">
        <span class="dash-search-ico" aria-hidden="true">âŒ•</span>
        <input id="fileSearch" class="dash-search-input" placeholder="æœç´¢æ–‡ä»¶/ç›®å½•" autocomplete="off" />
        <button id="fileSearchClear" class="dash-search-clear" type="button" title="æ¸…ç©º">Ã—</button>
      </div>

      <form method="post" action="/websites/{{ site.id }}/files/mkdir" class="row" style="gap:6px;align-items:center;flex-wrap:wrap;">
        <input type="hidden" name="path" value="{{ path }}">
        <input class="input" name="name" placeholder="æ–°å»ºç›®å½•" style="max-width:160px;">
        <button class="btn xs ghost" type="submit">åˆ›å»º</button>
      </form>

      <form id="uploadForm" method="post" action="/websites/{{ site.id }}/files/upload" enctype="multipart/form-data" class="row" style="gap:6px;align-items:center;flex-wrap:wrap;">
        <input type="hidden" name="path" value="{{ path }}">
        <input type="file" id="uploadFileInput" name="file" class="input" style="max-width:220px;">
        <button class="btn xs secondary" type="submit" id="uploadBtn">ä¸Šä¼ </button>
      </form>
    </div>
  </div>

  <div id="uploadPanel" style="margin-top:10px;display:none;">
    <div class="progress"><div class="progress-fill" id="uploadProgressFill"></div></div>
    <div class="muted sm" id="uploadStatus" style="margin-top:6px;"></div>
    <button class="btn xs ghost" type="button" id="uploadRetry" style="margin-top:8px;display:none;">é‡è¯•ä¸Šä¼ </button>
  </div>

  <div class="table-wrap" style="margin-top:12px;">
    <table class="table" id="filesTable">
      <thead>
        <tr>
          <th>åç§°</th>
          <th>å¤§å°</th>
          <th>ä¿®æ”¹æ—¶é—´</th>
          <th style="text-align:right;">æ“ä½œ</th>
        </tr>
      </thead>
      <tbody>
        {% for it in items %}
        <tr data-name="{{ (it.name or '')|lower }}" data-dir="{{ '1' if it.is_dir else '0' }}">
          <td>
            {% if it.is_dir %}
              <a href="/websites/{{ site.id }}/files?path={{ it.path }}" style="text-decoration:none;">ğŸ“ {{ it.name }}</a>
            {% else %}
              <span>ğŸ“„ {{ it.name }}</span>
            {% endif %}
          </td>
          <td class="mono">{{ it.size_h }}</td>
          <td class="mono">{{ it.mtime or "-" }}</td>
          <td style="text-align:right; white-space:nowrap;">
            <details class="menu">
              <summary class="btn xs ghost">æ“ä½œ â–¾</summary>
              <div class="menu-pop">
                {% if it.is_dir %}
                  <a class="menu-item" href="/websites/{{ site.id }}/files?path={{ it.path }}">è¿›å…¥ç›®å½•</a>
                  <div class="menu-sep"></div>
                {% else %}
                  <a class="menu-item" href="/websites/{{ site.id }}/files/edit?path={{ it.path }}">ç¼–è¾‘</a>
                  <a class="menu-item" href="/websites/{{ site.id }}/files/download?path={{ it.path }}">ä¸‹è½½</a>
                  <div class="menu-sep"></div>
                {% endif %}

                <form method="post" action="/websites/{{ site.id }}/files/delete" onsubmit="return confirm('ç¡®å®šåˆ é™¤ {{ it.name }} å—ï¼Ÿè¯¥æ“ä½œä¸å¯æ¢å¤ã€‚');">
                  <input type="hidden" name="path" value="{{ it.path }}">
                  <button class="menu-item" type="submit">åˆ é™¤</button>
                </form>
              </div>
            </details>
          </td>
        </tr>
        {% else %}
        <tr>
          <td colspan="4" class="muted">å½“å‰ç›®å½•ä¸ºç©º</td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
  // -------- File list search --------
  (function(){
    const input = document.getElementById('fileSearch');
    const clear = document.getElementById('fileSearchClear');
    const table = document.getElementById('filesTable');
    if(!input || !table) return;
    const rows = Array.from(table.querySelectorAll('tbody tr[data-name]'));

    function apply(){
      const q = (input.value || '').trim().toLowerCase();
      rows.forEach(r => {
        const name = r.dataset.name || '';
        r.style.display = (!q || name.includes(q)) ? '' : 'none';
      });
    }

    input.addEventListener('input', apply);
    clear?.addEventListener('click', () => { input.value=''; input.focus(); apply(); });
  })();

  // -------- Chunked upload (resume capable) --------
  (function(){
    const uploadForm = document.getElementById('uploadForm');
    const uploadFileInput = document.getElementById('uploadFileInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const uploadPanel = document.getElementById('uploadPanel');
    const uploadProgressFill = document.getElementById('uploadProgressFill');
    const uploadStatus = document.getElementById('uploadStatus');
    const uploadRetry = document.getElementById('uploadRetry');

    const CHUNK_SIZE = 1024 * 512;
    const SITE_ID = {{ site.id }};
    const CUR_PATH = {{ path|tojson }};

    if(!uploadForm || !uploadFileInput || !uploadBtn) return;

    function bytesToHuman(n){
      if(!n) return '0 B';
      const units = ['B','KB','MB','GB','TB'];
      let i = 0;
      let v = n;
      while(v >= 1024 && i < units.length - 1){
        v /= 1024;
        i++;
      }
      return v.toFixed(1) + ' ' + units[i];
    }

    function bufToHex(buffer){
      const bytes = new Uint8Array(buffer);
      const hex = [];
      for(const b of bytes){
        hex.push(b.toString(16).padStart(2, '0'));
      }
      return hex.join('');
    }

    async function sha256Hex(arrayBuffer){
      const hash = await crypto.subtle.digest('SHA-256', arrayBuffer);
      return bufToHex(hash);
    }

    function chunkToBase64(arrayBuffer){
      // Faster + safer than byte-by-byte string concatenation.
      const bytes = new Uint8Array(arrayBuffer);
      let binary = '';
      const step = 0x8000; // 32KB
      for(let i=0;i<bytes.length;i+=step){
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i+step));
      }
      return btoa(binary);
    }

    function uploadKey(file){
      return `nexus_upload_${SITE_ID}_${CUR_PATH}_${file.name}_${file.size}_${file.lastModified}`;
    }

    async function getResumeOffset(file, uploadId){
      const resp = await fetch(`/websites/${SITE_ID}/files/upload_status`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ path: CUR_PATH, filename: file.name, upload_id: uploadId })
      });
      const data = await resp.json().catch(()=>({ok:false}));
      if(!data.ok) return 0;
      return parseInt(data.offset || 0, 10) || 0;
    }

    async function uploadFile(file, uploadId, startOffset){
      let offset = startOffset || 0;
      const total = file.size;

      uploadPanel.style.display = 'block';
      uploadRetry.style.display = 'none';
      uploadBtn.disabled = true;
      uploadStatus.textContent = `å‡†å¤‡ä¸Šä¼  ${file.name} (${bytesToHuman(total)})â€¦`;

      while(offset < total){
        const chunk = file.slice(offset, offset + CHUNK_SIZE);
        const buf = await chunk.arrayBuffer();
        const chunkSha = await sha256Hex(buf);
        const b64 = chunkToBase64(buf);
        const done = (offset + chunk.size) >= total;

        const resp = await fetch(`/websites/${SITE_ID}/files/upload_chunk`, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({
            path: CUR_PATH,
            filename: file.name,
            upload_id: uploadId,
            offset: offset,
            done: done,
            content_b64: b64,
            chunk_sha256: chunkSha
          })
        });

        const data = await resp.json().catch(()=>({ok:false,error:'ä¸Šä¼ å¤±è´¥'}));
        if(!data.ok){
          if(data.expected_offset !== undefined){
            offset = parseInt(data.expected_offset || 0, 10) || 0;
            continue;
          }
          throw new Error(data.error || 'ä¸Šä¼ å¤±è´¥');
        }

        offset += chunk.size;
        const pct = Math.min(100, Math.round((offset / total) * 100));
        uploadProgressFill.style.width = pct + '%';
        uploadStatus.textContent = `å·²ä¸Šä¼  ${bytesToHuman(offset)} / ${bytesToHuman(total)} (${pct}%)`;
        localStorage.setItem(uploadKey(file), uploadId);
      }

      localStorage.removeItem(uploadKey(file));
      uploadStatus.textContent = 'ä¸Šä¼ å®Œæˆ';
      uploadBtn.disabled = false;
    }

    uploadForm.addEventListener('submit', async (e)=>{
      // Fallback: if browser doesn't support WebCrypto, let the server handle upload.
      if(!window.crypto || !window.crypto.subtle){
        return;
      }
      e.preventDefault();

      const file = uploadFileInput.files?.[0];
      if(!file){
        alert('è¯·é€‰æ‹©æ–‡ä»¶');
        return;
      }

      const key = uploadKey(file);
      let uploadId = localStorage.getItem(key) || '';
      if(!uploadId){
        uploadId = Math.random().toString(16).slice(2) + Date.now().toString(16);
      }

      try{
        const offset = await getResumeOffset(file, uploadId);
        await uploadFile(file, uploadId, offset);
        window.location.reload();
      }catch(err){
        uploadStatus.textContent = String(err);
        uploadRetry.style.display = 'inline-block';
        uploadBtn.disabled = false;
      }
    });

    uploadRetry?.addEventListener('click', async ()=>{
      const file = uploadFileInput.files?.[0];
      if(!file) return;
      const key = uploadKey(file);
      const uploadId = localStorage.getItem(key) || '';
      if(!uploadId){
        uploadStatus.textContent = 'æ‰¾ä¸åˆ°å¯æ¢å¤çš„ä¸Šä¼ ';
        return;
      }
      try{
        const offset = await getResumeOffset(file, uploadId);
        await uploadFile(file, uploadId, offset);
        window.location.reload();
      }catch(err){
        uploadStatus.textContent = String(err);
        uploadBtn.disabled = false;
      }
    });
  })();
</script>
{% endblock %}
